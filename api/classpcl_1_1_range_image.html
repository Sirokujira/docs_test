

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Class RangeImage &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html">Table of contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#features">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#filtering">Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#i-o">I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#keypoints">Keypoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#kdtree">KdTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#octree">Octree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#range-images">Range Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#recognition">Recognition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#registration">Registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#sample-consensus">Sample Consensus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#segmentation">Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#surface">Surface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#visualization">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#applications">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/tutorials/content/index.html#gpu">GPU</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Topics:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/advanced/content/index.html">Compiling PCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/advanced/content/index.html#developing-pcl-code">Developing PCL code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/advanced/content/index.html#committing-changes-to-the-git-master">Committing changes to the git master</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/advanced/content/index.html#improving-the-pcl-documentation">Improving the PCL documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcl/doc/advanced/content/index.html#how-to-build-a-minimal-example">How to build a minimal example</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Class RangeImage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/classpcl_1_1_range_image.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="class-rangeimage">
<span id="exhale-class-classpcl-1-1-range-image"></span><h1>Class RangeImage<a class="headerlink" href="#class-rangeimage" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Defined in <a class="reference internal" href="file_pcl_common_include_pcl_range_image_range_image.h.html#file-pcl-common-include-pcl-range-image-range-image-h"><span class="std std-ref">File range_image.h</span></a></p></li>
</ul>
<div class="section" id="inheritance-relationships">
<h2>Inheritance Relationships<a class="headerlink" href="#inheritance-relationships" title="Permalink to this headline">¶</a></h2>
<div class="section" id="base-type">
<h3>Base Type<a class="headerlink" href="#base-type" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">pcl::PointCloud&lt;</span> <span class="pre">PointWithRange</span> <span class="pre">&gt;</span></code> (<a class="reference internal" href="classpcl_1_1_point_cloud.html#exhale-class-classpcl-1-1-point-cloud"><span class="std std-ref">Template Class PointCloud</span></a>)</p></li>
</ul>
</div>
<div class="section" id="derived-types">
<h3>Derived Types<a class="headerlink" href="#derived-types" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">pcl::RangeImagePlanar</span></code> (<a class="reference internal" href="classpcl_1_1_range_image_planar.html#exhale-class-classpcl-1-1-range-image-planar"><span class="std std-ref">Class RangeImagePlanar</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">pcl::RangeImageSpherical</span></code> (<a class="reference internal" href="classpcl_1_1_range_image_spherical.html#exhale-class-classpcl-1-1-range-image-spherical"><span class="std std-ref">Class RangeImageSpherical</span></a>)</p></li>
</ul>
</div>
</div>
<div class="section" id="class-documentation">
<h2>Class Documentation<a class="headerlink" href="#class-documentation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N3pcl10RangeImageE">
<span id="_CPPv3N3pcl10RangeImageE"></span><span id="_CPPv2N3pcl10RangeImageE"></span><span id="pcl::RangeImage"></span><span class="target" id="classpcl_1_1_range_image"></span><em class="property">class </em><code class="sig-name descname">RangeImage</code> : <em class="property">public</em> pcl::PointCloud&lt;<a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a>&gt;<a class="headerlink" href="#_CPPv4N3pcl10RangeImageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classpcl_1_1_range_image"><span class="std std-ref">RangeImage</span></a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point. </p>
<p><dl class="simple">
<dt><strong>Author</strong></dt><dd><p>Bastian Steder </p>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="classpcl_1_1_range_image_planar.html#classpcl_1_1_range_image_planar"><span class="std std-ref">pcl::RangeImagePlanar</span></a>, <a class="reference internal" href="classpcl_1_1_range_image_spherical.html#classpcl_1_1_range_image_spherical"><span class="std std-ref">pcl::RangeImageSpherical</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="enum">
<dt id="_CPPv4N3pcl10RangeImage15CoordinateFrameE">
<span id="_CPPv3N3pcl10RangeImage15CoordinateFrameE"></span><span id="_CPPv2N3pcl10RangeImage15CoordinateFrameE"></span><span class="target" id="classpcl_1_1_range_image_1a8b5785b0499f0a70d5c87fceba55992f"></span><em class="property">enum </em><code class="sig-name descname">CoordinateFrame</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE">
<span id="_CPPv3N3pcl10RangeImage12CAMERA_FRAMEE"></span><span id="_CPPv2N3pcl10RangeImage12CAMERA_FRAMEE"></span><span class="target" id="classpcl_1_1_range_image_1a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf"></span><code class="sig-name descname">CAMERA_FRAME</code> = 0<a class="headerlink" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv4N3pcl10RangeImage11LASER_FRAMEE">
<span id="_CPPv3N3pcl10RangeImage11LASER_FRAMEE"></span><span id="_CPPv2N3pcl10RangeImage11LASER_FRAMEE"></span><span class="target" id="classpcl_1_1_range_image_1a8b5785b0499f0a70d5c87fceba55992faa7e6d8ab63f2359fd25c11db114db19c"></span><code class="sig-name descname">LASER_FRAME</code> = 1<a class="headerlink" href="#_CPPv4N3pcl10RangeImage11LASER_FRAMEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv4N3pcl10RangeImage9BaseClassE">
<span id="_CPPv3N3pcl10RangeImage9BaseClassE"></span><span id="_CPPv2N3pcl10RangeImage9BaseClassE"></span><span id="pcl::RangeImage::BaseClass"></span><span class="target" id="classpcl_1_1_range_image_1af0fcaf5bf99ac1b2dbde4e47ab189b42"></span><em class="property">typedef </em>pcl::PointCloud&lt;<a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a>&gt; <code class="sig-name descname">BaseClass</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage9BaseClassE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N3pcl10RangeImage21VectorOfEigenVector3fE">
<span id="_CPPv3N3pcl10RangeImage21VectorOfEigenVector3fE"></span><span id="_CPPv2N3pcl10RangeImage21VectorOfEigenVector3fE"></span><span id="pcl::RangeImage::VectorOfEigenVector3f"></span><span class="target" id="classpcl_1_1_range_image_1aaea2dbf0f2fa5e32bd59234b6d25c0c9"></span><em class="property">typedef </em>std::vector&lt;Eigen::Vector3f, Eigen::aligned_allocator&lt;Eigen::Vector3f&gt;&gt; <code class="sig-name descname">VectorOfEigenVector3f</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage21VectorOfEigenVector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N3pcl10RangeImage3PtrE">
<span id="_CPPv3N3pcl10RangeImage3PtrE"></span><span id="_CPPv2N3pcl10RangeImage3PtrE"></span><span id="pcl::RangeImage::Ptr"></span><span class="target" id="classpcl_1_1_range_image_1a8e40712f69557c1fa4219e2c9f744d9b"></span><em class="property">typedef </em>boost::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a>&gt; <code class="sig-name descname">Ptr</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage3PtrE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N3pcl10RangeImage8ConstPtrE">
<span id="_CPPv3N3pcl10RangeImage8ConstPtrE"></span><span id="_CPPv2N3pcl10RangeImage8ConstPtrE"></span><span id="pcl::RangeImage::ConstPtr"></span><span class="target" id="classpcl_1_1_range_image_1a4869553a830b95438de08fae4634cc74"></span><em class="property">typedef </em>boost::shared_ptr&lt;<em class="property">const</em> <a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a>&gt; <code class="sig-name descname">ConstPtr</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage8ConstPtrE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage10RangeImageEv">
<span id="_CPPv3N3pcl10RangeImage10RangeImageEv"></span><span id="_CPPv2N3pcl10RangeImage10RangeImageEv"></span><span id="pcl::RangeImage::RangeImage"></span><span class="target" id="classpcl_1_1_range_image_1af18b2d3410fb7799ad4de375b51df035"></span>PCL_EXPORTS <code class="sig-name descname">RangeImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage10RangeImageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImageD0Ev">
<span id="_CPPv3N3pcl10RangeImageD0Ev"></span><span id="_CPPv2N3pcl10RangeImageD0Ev"></span><span id="pcl::RangeImage::~RangeImage"></span><span class="target" id="classpcl_1_1_range_image_1a274fcd95e5f7c8da5f4f5ecf151bad40"></span><em class="property">virtual</em> PCL_EXPORTS <code class="sig-name descname">~RangeImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImageD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage10makeSharedEv">
<span id="_CPPv3N3pcl10RangeImage10makeSharedEv"></span><span id="_CPPv2N3pcl10RangeImage10makeSharedEv"></span><span id="pcl::RangeImage::makeShared"></span><span class="target" id="classpcl_1_1_range_image_1a7f898747aa6a52e484d65babc2600a23"></span><a class="reference internal" href="#_CPPv4N3pcl10RangeImage3PtrE" title="pcl::RangeImage::Ptr">Ptr</a> <code class="sig-name descname">makeShared</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage10makeSharedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a boost shared pointer of a copy of this. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1acd539d95dd7bbbd1d67db12e9be275b0"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::reset()</code></dt>
<dd><p>Reset all values to an empty range image. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage20createFromPointCloudERK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage20createFromPointCloudERK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1a82f6a143de2d73a0ad9fea6c527a2efb"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">createFromPointCloud</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloud::PointCloudType">PointCloudType</a> &amp;<em>point_cloud</em>, float <em>angular_resolution</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(0.5f), float <em>max_angle_width</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(360.0f), float <em>max_angle_height</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(180.0f), <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution</span></code>: the angular difference (in radians) between the individual pixels in the image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypeffffRKN5Eigen8Affine3fE15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage20createFromPointCloudERK14PointCloudTypeffffRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage20createFromPointCloudERK14PointCloudTypeffffRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1ae3a8a2def6dde7446b9fc456f7992aa9"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">createFromPointCloud</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypefffRKN5Eigen8Affine3fE15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloud::PointCloudType">PointCloudType</a> &amp;<em>point_cloud</em>, float <em>angular_resolution_x</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(0.5f), float <em>angular_resolution_y</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(0.5f), float <em>max_angle_width</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(360.0f), float <em>max_angle_height</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(180.0f), <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage20createFromPointCloudEvRK14PointCloudTypeffffRKN5Eigen8Affine3fE15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_x</span></code>: the angular difference (in radians) between the individual pixels in the image in the x-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_y</span></code>: the angular difference (in radians) between the individual pixels in the image in the y-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeERK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeERK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1afbb553405d9b1df2b10b08c98c052250"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">createFromPointCloudWithKnownSize</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloudWithKnownSize::PointCloudType">PointCloudType</a> &amp;<em>point_cloud</em>, float <em>angular_resolution</em>, <em class="property">const</em> Eigen::Vector3f &amp;<em>point_cloud_center</em>, float <em>point_cloud_radius</em>, <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution</span></code>: the angle (in radians) between each sample in the depth image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud_center</span></code>: the center of bounding sphere </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud_radius</span></code>: the radius of the bounding sphere </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypeffRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeERK14PointCloudTypeffRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeERK14PointCloudTypeffRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1ac52b84843090cf756a37c596b5e772d2"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">createFromPointCloudWithKnownSize</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypefRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloudWithKnownSize::PointCloudType">PointCloudType</a> &amp;<em>point_cloud</em>, float <em>angular_resolution_x</em>, float <em>angular_resolution_y</em>, <em class="property">const</em> Eigen::Vector3f &amp;<em>point_cloud_center</em>, float <em>point_cloud_radius</em>, <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage33createFromPointCloudWithKnownSizeEvRK14PointCloudTypeffRKN5Eigen8Vector3fEfRKN5Eigen8Affine3fE15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_x</span></code>: the angular difference (in radians) between the individual pixels in the image in the x-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_y</span></code>: the angular difference (in radians) between the individual pixels in the image in the y-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud_center</span></code>: the center of bounding sphere </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud_radius</span></code>: the radius of the bounding sphere </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsERK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsERK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1a91cb7406e0e57923a7f5d533ea578c0f"></span>template&lt;typename <code class="sig-name descname">PointCloudTypeWithViewpoints</code>&gt;<br />void <code class="sig-name descname">createFromPointCloudWithViewpoints</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloudWithViewpoints::PointCloudTypeWithViewpoints">PointCloudTypeWithViewpoints</a> &amp;<em>point_cloud</em>, float <em>angular_resolution</em>, float <em>max_angle_width</em>, float <em>max_angle_height</em>, <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution</span></code>: the angle (in radians) between each sample in the depth image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsffff15CoordinateFrameffi">
<span id="_CPPv3I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsERK28PointCloudTypeWithViewpointsffff15CoordinateFrameffi"></span><span id="_CPPv2I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsERK28PointCloudTypeWithViewpointsffff15CoordinateFrameffi"></span><span class="target" id="classpcl_1_1_range_image_1a66de72c9511e694d41bd7a48c043f541"></span>template&lt;typename <code class="sig-name descname">PointCloudTypeWithViewpoints</code>&gt;<br />void <code class="sig-name descname">createFromPointCloudWithViewpoints</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsfff15CoordinateFrameffi" title="pcl::RangeImage::createFromPointCloudWithViewpoints::PointCloudTypeWithViewpoints">PointCloudTypeWithViewpoints</a> &amp;<em>point_cloud</em>, float <em>angular_resolution_x</em>, float <em>angular_resolution_y</em>, float <em>max_angle_width</em>, float <em>max_angle_height</em>, <a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>noise_level</em> = 0.0f, float <em>min_range</em> = 0.0f, int <em>border_size</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage34createFromPointCloudWithViewpointsEvRK28PointCloudTypeWithViewpointsffff15CoordinateFrameffi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_x</span></code>: the angular difference (in radians) between the individual pixels in the image in the x-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_y</span></code>: the angular difference (in radians) between the individual pixels in the image in the y-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: the border size (defaults to 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage11createEmptyEfRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff">
<span id="_CPPv3N3pcl10RangeImage11createEmptyEfRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff"></span><span id="_CPPv2N3pcl10RangeImage11createEmptyEfRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff"></span><span id="pcl::RangeImage::createEmpty__float.Eigen::Affine3fCR.RangeImage::CoordinateFrame.float.float"></span><span class="target" id="classpcl_1_1_range_image_1a46cb318d3d6f1cf6aace8d2ed10ed7fa"></span>void <code class="sig-name descname">createEmpty</code><span class="sig-paren">(</span>float <em>angular_resolution</em>, <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a>::<a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>angle_width</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(360.0f), float <em>angle_height</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(180.0f)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage11createEmptyEfRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an empty depth image (filled with unobserved points) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">angular_resolution</span></code>: the angle (in radians) between each sample in the depth image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage11createEmptyEffRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff">
<span id="_CPPv3N3pcl10RangeImage11createEmptyEffRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff"></span><span id="_CPPv2N3pcl10RangeImage11createEmptyEffRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff"></span><span id="pcl::RangeImage::createEmpty__float.float.Eigen::Affine3fCR.RangeImage::CoordinateFrame.float.float"></span><span class="target" id="classpcl_1_1_range_image_1afa9ecf76f97e99ede5b71bb7da6c1715"></span>void <code class="sig-name descname">createEmpty</code><span class="sig-paren">(</span>float <em>angular_resolution_x</em>, float <em>angular_resolution_y</em>, <em class="property">const</em> Eigen::Affine3f &amp;<em>sensor_pose</em> = Eigen::Affine3f::Identity(), <a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a>::<a class="reference internal" href="#_CPPv4N3pcl10RangeImage15CoordinateFrameE" title="pcl::RangeImage::CoordinateFrame">CoordinateFrame</a> <em>coordinate_frame</em> = <a class="reference internal" href="#_CPPv4N3pcl10RangeImage12CAMERA_FRAMEE" title="pcl::RangeImage::CAMERA_FRAME">CAMERA_FRAME</a>, float <em>angle_width</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(360.0f), float <em>angle_height</em> = pcl::<a class="reference internal" href="function_group__common_1ga25b0ce695e2a10abb0130bcb5cf90eb6.html#_CPPv4N3pcl7deg2radEf" title="pcl::deg2rad">deg2rad</a>(180.0f)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage11createEmptyEffRKN5Eigen8Affine3fEN10RangeImage15CoordinateFrameEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an empty depth image (filled with unobserved points) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_x</span></code>: the angular difference (in radians) between the individual pixels in the image in the x-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_y</span></code>: the angular difference (in radians) between the individual pixels in the image in the y-direction </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">sensor_pose</span></code>: an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">coordinate_frame</span></code>: the coordinate frame (defaults to CAMERA_FRAME) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">angle_width</span></code>: an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">angle_height</span></code>: an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage9doZBufferEvRK14PointCloudTypeffRiRiRiRi">
<span id="_CPPv3I0EN3pcl10RangeImage9doZBufferERK14PointCloudTypeffRiRiRiRi"></span><span id="_CPPv2I0EN3pcl10RangeImage9doZBufferERK14PointCloudTypeffRiRiRiRi"></span><span class="target" id="classpcl_1_1_range_image_1a56655a55b4c83c7ce301ca0f020759b4"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">doZBuffer</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage9doZBufferEvRK14PointCloudTypeffRiRiRiRi" title="pcl::RangeImage::doZBuffer::PointCloudType">PointCloudType</a> &amp;<em>point_cloud</em>, float <em>noise_level</em>, float <em>min_range</em>, int &amp;<em>top</em>, int &amp;<em>right</em>, int &amp;<em>bottom</em>, int &amp;<em>left</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage9doZBufferEvRK14PointCloudTypeffRiRiRiRi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Integrate the given point cloud into the current range image using a z-buffer. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_level</span></code>: - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_range</span></code>: the minimum visible range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">top</span></code>: returns the minimum y pixel position in the image where a point was added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: returns the maximum x pixel position in the image where a point was added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bottom</span></code>: returns the maximum y pixel position in the image where a point was added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">top</span></code>: returns the minimum y position in the image where a point was added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: returns the minimum x pixel position in the image where a point was added </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage18integrateFarRangesEvRK14PointCloudType">
<span id="_CPPv3I0EN3pcl10RangeImage18integrateFarRangesERK14PointCloudType"></span><span id="_CPPv2I0EN3pcl10RangeImage18integrateFarRangesERK14PointCloudType"></span><span class="target" id="classpcl_1_1_range_image_1a6c3ceb66679ccc84587eef5c29a16386"></span>template&lt;typename <code class="sig-name descname">PointCloudType</code>&gt;<br />void <code class="sig-name descname">integrateFarRanges</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage18integrateFarRangesEvRK14PointCloudType" title="pcl::RangeImage::integrateFarRanges::PointCloudType">PointCloudType</a> &amp;<em>far_ranges</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage18integrateFarRangesEvRK14PointCloudType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Integrates the given far range measurements into the range image. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a20f223d93080e9ce32122f90a265f7c4"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::cropImage(int border_size = 0, int top = -1, int right = -1, int bottom = -1, int left = -1)</code></dt>
<dd><p>Cut the range image to the minimal size so that it still contains all actual range readings. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">border_size</span></code>: allows increase from the minimal size by the specified number of pixels (defaults to 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">top</span></code>: if positive, this value overrides the position of the top edge (defaults to -1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: if positive, this value overrides the position of the right edge (defaults to -1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bottom</span></code>: if positive, this value overrides the position of the bottom edge (defaults to -1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: if positive, this value overrides the position of the left edge (defaults to -1) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1ab124a58f66b1d9a5d0f433c8474ef2b4"></span><code class="sig-name descname">PCL_EXPORTS float* pcl::RangeImage::getRangesArray() const</code></dt>
<dd><p>Get all the range values in one float array of size width*height </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a pointer to a new float array containing the range values </p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method allocates a new float array; the caller is responsible for freeing this memory. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage35getTransformationToRangeImageSystemEv">
<span id="_CPPv3NK3pcl10RangeImage35getTransformationToRangeImageSystemEv"></span><span id="_CPPv2NK3pcl10RangeImage35getTransformationToRangeImageSystemEv"></span><span id="pcl::RangeImage::getTransformationToRangeImageSystemC"></span><span class="target" id="classpcl_1_1_range_image_1ac503c8e060a6f6b1cae1c1fa87fa6e33"></span><em class="property">const</em> Eigen::Affine3f &amp;<code class="sig-name descname">getTransformationToRangeImageSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage35getTransformationToRangeImageSystemEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the transformation from the world system into the range image system (the sensor coordinate frame) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage35setTransformationToRangeImageSystemERKN5Eigen8Affine3fE">
<span id="_CPPv3N3pcl10RangeImage35setTransformationToRangeImageSystemERKN5Eigen8Affine3fE"></span><span id="_CPPv2N3pcl10RangeImage35setTransformationToRangeImageSystemERKN5Eigen8Affine3fE"></span><span id="pcl::RangeImage::setTransformationToRangeImageSystem__Eigen::Affine3fCR"></span><span class="target" id="classpcl_1_1_range_image_1ab0419b66dd9e76fbc6d568049abfad3c"></span>void <code class="sig-name descname">setTransformationToRangeImageSystem</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Affine3f &amp;<em>to_range_image_system</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage35setTransformationToRangeImageSystemERKN5Eigen8Affine3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Setter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage30getTransformationToWorldSystemEv">
<span id="_CPPv3NK3pcl10RangeImage30getTransformationToWorldSystemEv"></span><span id="_CPPv2NK3pcl10RangeImage30getTransformationToWorldSystemEv"></span><span id="pcl::RangeImage::getTransformationToWorldSystemC"></span><span class="target" id="classpcl_1_1_range_image_1afdff6ffbb3bfec294637225b5fb82956"></span><em class="property">const</em> Eigen::Affine3f &amp;<code class="sig-name descname">getTransformationToWorldSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage30getTransformationToWorldSystemEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage20getAngularResolutionEv">
<span id="_CPPv3NK3pcl10RangeImage20getAngularResolutionEv"></span><span id="_CPPv2NK3pcl10RangeImage20getAngularResolutionEv"></span><span id="pcl::RangeImage::getAngularResolutionC"></span><span class="target" id="classpcl_1_1_range_image_1a6fc3548b0b33e90cead2c1ecfce14c34"></span>float <code class="sig-name descname">getAngularResolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage20getAngularResolutionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>
<p>Provided for downwards compatibility </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage21getAngularResolutionXEv">
<span id="_CPPv3NK3pcl10RangeImage21getAngularResolutionXEv"></span><span id="_CPPv2NK3pcl10RangeImage21getAngularResolutionXEv"></span><span id="pcl::RangeImage::getAngularResolutionXC"></span><span class="target" id="classpcl_1_1_range_image_1a6522dbfac4997c15bd24b0b9b3e9d4dd"></span>float <code class="sig-name descname">getAngularResolutionX</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage21getAngularResolutionXEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage21getAngularResolutionYEv">
<span id="_CPPv3NK3pcl10RangeImage21getAngularResolutionYEv"></span><span id="_CPPv2NK3pcl10RangeImage21getAngularResolutionYEv"></span><span id="pcl::RangeImage::getAngularResolutionYC"></span><span class="target" id="classpcl_1_1_range_image_1af4891c9812652efe513b9ff060490364"></span>float <code class="sig-name descname">getAngularResolutionY</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage21getAngularResolutionYEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the angular resolution of the range image in y direction in radians per pixel. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage20getAngularResolutionERfRf">
<span id="_CPPv3NK3pcl10RangeImage20getAngularResolutionERfRf"></span><span id="_CPPv2NK3pcl10RangeImage20getAngularResolutionERfRf"></span><span id="pcl::RangeImage::getAngularResolution__floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a41c0b0f74510988357a56fdc48d18f93"></span>void <code class="sig-name descname">getAngularResolution</code><span class="sig-paren">(</span>float &amp;<em>angular_resolution_x</em>, float &amp;<em>angular_resolution_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage20getAngularResolutionERfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for the angular resolution of the range image in x and y direction (in radians). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage20setAngularResolutionEf">
<span id="_CPPv3N3pcl10RangeImage20setAngularResolutionEf"></span><span id="_CPPv2N3pcl10RangeImage20setAngularResolutionEf"></span><span id="pcl::RangeImage::setAngularResolution__float"></span><span class="target" id="classpcl_1_1_range_image_1a2720450161caef9a2992b0ac943ab2b7"></span>void <code class="sig-name descname">setAngularResolution</code><span class="sig-paren">(</span>float <em>angular_resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage20setAngularResolutionEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the angular resolution of the range image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution</span></code>: the new angular resolution in x and y direction (in radians per pixel) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage20setAngularResolutionEff">
<span id="_CPPv3N3pcl10RangeImage20setAngularResolutionEff"></span><span id="_CPPv2N3pcl10RangeImage20setAngularResolutionEff"></span><span id="pcl::RangeImage::setAngularResolution__float.float"></span><span class="target" id="classpcl_1_1_range_image_1a74583440e4ef4b611b7d2b638c6da28e"></span>void <code class="sig-name descname">setAngularResolution</code><span class="sig-paren">(</span>float <em>angular_resolution_x</em>, float <em>angular_resolution_y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage20setAngularResolutionEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the angular resolution of the range image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_x</span></code>: the new angular resolution in x direction (in radians per pixel) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angular_resolution_y</span></code>: the new angular resolution in y direction (in radians per pixel) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage8getPointEii">
<span id="_CPPv3NK3pcl10RangeImage8getPointEii"></span><span id="_CPPv2NK3pcl10RangeImage8getPointEii"></span><span id="pcl::RangeImage::getPoint__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a52164736793c99cc9fc48dedee615e45"></span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>int <em>image_x</em>, int <em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage8getPointEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 3D point with range at the given image position. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the point at the specified location (returns unobserved_point if outside of the image bounds) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image_x</span></code>: the x coordinate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_y</span></code>: the y coordinate </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage8getPointEii">
<span id="_CPPv3N3pcl10RangeImage8getPointEii"></span><span id="_CPPv2N3pcl10RangeImage8getPointEii"></span><span id="pcl::RangeImage::getPoint__i.i"></span><span class="target" id="classpcl_1_1_range_image_1adb229f49ccf885517e905373372b00be"></span><a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>int <em>image_x</em>, int <em>image_y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage8getPointEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-const-version of getPoint. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage8getPointEff">
<span id="_CPPv3NK3pcl10RangeImage8getPointEff"></span><span id="_CPPv2NK3pcl10RangeImage8getPointEff"></span><span id="pcl::RangeImage::getPoint__float.floatC"></span><span class="target" id="classpcl_1_1_range_image_1a0168934416e10ded1eb34d57123b8d37"></span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage8getPointEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 3d point with range at the given image position. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage8getPointEff">
<span id="_CPPv3N3pcl10RangeImage8getPointEff"></span><span id="_CPPv2N3pcl10RangeImage8getPointEff"></span><span id="pcl::RangeImage::getPoint__float.float"></span><span class="target" id="classpcl_1_1_range_image_1aa403d6ee9c3d76a50b268204acab27ff"></span><a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage8getPointEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-const-version of the above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage15getPointNoCheckEii">
<span id="_CPPv3NK3pcl10RangeImage15getPointNoCheckEii"></span><span id="_CPPv2NK3pcl10RangeImage15getPointNoCheckEii"></span><span id="pcl::RangeImage::getPointNoCheck__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a587663a5b4123f4c423c9e38a9b36d41"></span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPointNoCheck</code><span class="sig-paren">(</span>int <em>image_x</em>, int <em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage15getPointNoCheckEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 3D point with range at the given image position. </p>
<p>This methd performs no error checking to make sure the specified image position is inside of the image! <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the point at the specified location (program may fail if the location is outside of the image bounds) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image_x</span></code>: the x coordinate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_y</span></code>: the y coordinate </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage15getPointNoCheckEii">
<span id="_CPPv3N3pcl10RangeImage15getPointNoCheckEii"></span><span id="_CPPv2N3pcl10RangeImage15getPointNoCheckEii"></span><span id="pcl::RangeImage::getPointNoCheck__i.i"></span><span class="target" id="classpcl_1_1_range_image_1a45bfd00007940d0043b8f1df43663d07"></span><a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPointNoCheck</code><span class="sig-paren">(</span>int <em>image_x</em>, int <em>image_y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15getPointNoCheckEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-const-version of getPointNoCheck. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage8getPointEiiRN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage8getPointEiiRN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage8getPointEiiRN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getPoint__i.i.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1a35a8dbb8cc328029a928b3cff4225d5b"></span>void <code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>int <em>image_x</em>, int <em>image_y</em>, Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage8getPointEiiRN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage8getPointEiRN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage8getPointEiRN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage8getPointEiRN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getPoint__i.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1aa7e520479cc8f66e5ddd7f594649b25f"></span>void <code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>int <em>index</em>, Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage8getPointEiRN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16getEigenVector3fEii">
<span id="_CPPv3NK3pcl10RangeImage16getEigenVector3fEii"></span><span id="_CPPv2NK3pcl10RangeImage16getEigenVector3fEii"></span><span id="pcl::RangeImage::getEigenVector3f__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a63716da3dad788cd23b64e9dc67b1791"></span><em class="property">const</em> Eigen::Map&lt;<em class="property">const</em> Eigen::Vector3f&gt; <code class="sig-name descname">getEigenVector3f</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16getEigenVector3fEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16getEigenVector3fEi">
<span id="_CPPv3NK3pcl10RangeImage16getEigenVector3fEi"></span><span id="_CPPv2NK3pcl10RangeImage16getEigenVector3fEi"></span><span id="pcl::RangeImage::getEigenVector3f__iC"></span><span class="target" id="classpcl_1_1_range_image_1aab3ee4df50d138b9f9b4ba34306c1071"></span><em class="property">const</em> Eigen::Map&lt;<em class="property">const</em> Eigen::Vector3f&gt; <code class="sig-name descname">getEigenVector3f</code><span class="sig-paren">(</span>int <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16getEigenVector3fEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage8getPointEi">
<span id="_CPPv3NK3pcl10RangeImage8getPointEi"></span><span id="_CPPv2NK3pcl10RangeImage8getPointEi"></span><span id="pcl::RangeImage::getPoint__iC"></span><span class="target" id="classpcl_1_1_range_image_1a467a03da34e4ffd323ae0f080ac85570"></span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<code class="sig-name descname">getPoint</code><span class="sig-paren">(</span>int <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage8getPointEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 3d point with range at the given index (whereas index=y*width+x) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16calculate3DPointEfffR14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage16calculate3DPointEfffR14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage16calculate3DPointEfffR14PointWithRange"></span><span id="pcl::RangeImage::calculate3DPoint__float.float.float.PointWithRangeRC"></span><span class="target" id="classpcl_1_1_range_image_1a1acc16b4b5fb7071175bada62a5b75d0"></span>void <code class="sig-name descname">calculate3DPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em>, float <em>range</em>, <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16calculate3DPointEfffR14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the 3D point according to the given image point and range. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16calculate3DPointEffR14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage16calculate3DPointEffR14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage16calculate3DPointEffR14PointWithRange"></span><span id="pcl::RangeImage::calculate3DPoint__float.float.PointWithRangeRC"></span><span class="target" id="classpcl_1_1_range_image_1a0f969bd0149b7848f0f26b44bb88035c"></span>void <code class="sig-name descname">calculate3DPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em>, <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16calculate3DPointEffR14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16calculate3DPointEfffRN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage16calculate3DPointEfffRN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage16calculate3DPointEfffRN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::calculate3DPoint__float.float.float.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1aa9e97e7487ac21a77075b5f8b64ca205"></span>void <code class="sig-name descname">calculate3DPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em>, float <em>range</em>, Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16calculate3DPointEfffRN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the 3D point according to the given image point and range. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage16calculate3DPointEffRN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage16calculate3DPointEffRN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage16calculate3DPointEffRN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::calculate3DPoint__float.float.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1abbb77866cf4ee5d2a619f4f8cc62cc9b"></span>void <code class="sig-name descname">calculate3DPoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em>, Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage16calculate3DPointEffRN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a08d6ccfef80c3788102327df618a3fbf"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::recalculate3DPointPositions()</code></dt>
<dd><p>Recalculate all 3D point positions according to their pixel position and range. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRfRf">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRfRf"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRfRf"></span><span id="pcl::RangeImage::getImagePoint__Eigen::Vector3fCR.floatR.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a7a53bfc9f4a3365ee8e62513ae37eb5c"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, float &amp;<em>image_x</em>, float &amp;<em>image_y</em>, float &amp;<em>range</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get imagePoint from 3D point in world coordinates. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRiRf">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRiRf"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRiRf"></span><span id="pcl::RangeImage::getImagePoint__Eigen::Vector3fCR.iR.iR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a9295b795c8f52a90eb3af983612fea8a"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, int &amp;<em>image_x</em>, int &amp;<em>image_y</em>, float &amp;<em>range</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRiRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRf">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRf"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRf"></span><span id="pcl::RangeImage::getImagePoint__Eigen::Vector3fCR.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a8b9b678a491ddefc1109494157e0aa83"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, float &amp;<em>image_x</em>, float &amp;<em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRi">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRi"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRi"></span><span id="pcl::RangeImage::getImagePoint__Eigen::Vector3fCR.iR.iRC"></span><span class="target" id="classpcl_1_1_range_image_1aac7ef90b9c78876a492fd16701d6578e"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, int &amp;<em>image_x</em>, int &amp;<em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointERKN5Eigen8Vector3fERiRi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointEfffRfRfRf">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointEfffRfRfRf"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointEfffRfRfRf"></span><span id="pcl::RangeImage::getImagePoint__float.float.float.floatR.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a09c81c4b4ffd68fc5742167d15f6af87"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span>float <em>x</em>, float <em>y</em>, float <em>z</em>, float &amp;<em>image_x</em>, float &amp;<em>image_y</em>, float &amp;<em>range</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointEfffRfRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointEfffRfRf">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointEfffRfRf"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointEfffRfRf"></span><span id="pcl::RangeImage::getImagePoint__float.float.float.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a8123412373a87d5030ee5f8a9b3ba3e4"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span>float <em>x</em>, float <em>y</em>, float <em>z</em>, float &amp;<em>image_x</em>, float &amp;<em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointEfffRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13getImagePointEfffRiRi">
<span id="_CPPv3NK3pcl10RangeImage13getImagePointEfffRiRi"></span><span id="_CPPv2NK3pcl10RangeImage13getImagePointEfffRiRi"></span><span id="pcl::RangeImage::getImagePoint__float.float.float.iR.iRC"></span><span class="target" id="classpcl_1_1_range_image_1a2ba0bfce9adcf8161feec7c59f75082c"></span>void <code class="sig-name descname">getImagePoint</code><span class="sig-paren">(</span>float <em>x</em>, float <em>y</em>, float <em>z</em>, int &amp;<em>image_x</em>, int &amp;<em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13getImagePointEfffRiRi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage10checkPointERKN5Eigen8Vector3fER14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage10checkPointERKN5Eigen8Vector3fER14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage10checkPointERKN5Eigen8Vector3fER14PointWithRange"></span><span id="pcl::RangeImage::checkPoint__Eigen::Vector3fCR.PointWithRangeRC"></span><span class="target" id="classpcl_1_1_range_image_1a3e63aa0e7dc143f4a4a15611edcede70"></span>float <code class="sig-name descname">checkPoint</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point_in_image</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage10checkPointERKN5Eigen8Vector3fER14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>point_in_image will be the point in the image at the position the given point would be. </p>
<p>Returns the range of the given point. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage18getRangeDifferenceERKN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage18getRangeDifferenceERKN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage18getRangeDifferenceERKN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getRangeDifference__Eigen::Vector3fCRC"></span><span class="target" id="classpcl_1_1_range_image_1aea43fc18a9695437879d4b3b3860a9ae"></span>float <code class="sig-name descname">getRangeDifference</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage18getRangeDifferenceERKN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the difference in range between the given point and the range of the point in the image at the position the given point would be. </p>
<p>(Return value is point_in_image.range-given_point.range) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage23getImagePointFromAnglesEffRfRf">
<span id="_CPPv3NK3pcl10RangeImage23getImagePointFromAnglesEffRfRf"></span><span id="_CPPv2NK3pcl10RangeImage23getImagePointFromAnglesEffRfRf"></span><span id="pcl::RangeImage::getImagePointFromAngles__float.float.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1adfd931443541e194f1c53d5f7b1c43e6"></span>void <code class="sig-name descname">getImagePointFromAngles</code><span class="sig-paren">(</span>float <em>angle_x</em>, float <em>angle_y</em>, float &amp;<em>image_x</em>, float &amp;<em>image_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage23getImagePointFromAnglesEffRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the image point corresponding to the given angles. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage23getAnglesFromImagePointEffRfRf">
<span id="_CPPv3NK3pcl10RangeImage23getAnglesFromImagePointEffRfRf"></span><span id="_CPPv2NK3pcl10RangeImage23getAnglesFromImagePointEffRfRf"></span><span id="pcl::RangeImage::getAnglesFromImagePoint__float.float.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1a2388ab60ff312e9034df5e67f899ea97"></span>void <code class="sig-name descname">getAnglesFromImagePoint</code><span class="sig-paren">(</span>float <em>image_x</em>, float <em>image_y</em>, float &amp;<em>angle_x</em>, float &amp;<em>angle_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage23getAnglesFromImagePointEffRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the angles corresponding to the given image point. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage13real2DToInt2DEffRiRi">
<span id="_CPPv3NK3pcl10RangeImage13real2DToInt2DEffRiRi"></span><span id="_CPPv2NK3pcl10RangeImage13real2DToInt2DEffRiRi"></span><span id="pcl::RangeImage::real2DToInt2D__float.float.iR.iRC"></span><span class="target" id="classpcl_1_1_range_image_1a86174b766aa77898e0d49ef11f4613b1"></span>void <code class="sig-name descname">real2DToInt2D</code><span class="sig-paren">(</span>float <em>x</em>, float <em>y</em>, int &amp;<em>xInt</em>, int &amp;<em>yInt</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage13real2DToInt2DEffRiRi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transforms an image point in float values to an image point in int values. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage9isInImageEii">
<span id="_CPPv3NK3pcl10RangeImage9isInImageEii"></span><span id="_CPPv2NK3pcl10RangeImage9isInImageEii"></span><span id="pcl::RangeImage::isInImage__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a824a6bb27b43a174da775a656b81a483"></span>bool <code class="sig-name descname">isInImage</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage9isInImageEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a point is inside of the image. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage7isValidEii">
<span id="_CPPv3NK3pcl10RangeImage7isValidEii"></span><span id="_CPPv2NK3pcl10RangeImage7isValidEii"></span><span id="pcl::RangeImage::isValid__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a2372989721c3c119bb5d4b5ebd9b59c3"></span>bool <code class="sig-name descname">isValid</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage7isValidEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a point is inside of the image and has a finite range. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage7isValidEi">
<span id="_CPPv3NK3pcl10RangeImage7isValidEi"></span><span id="_CPPv2NK3pcl10RangeImage7isValidEi"></span><span id="pcl::RangeImage::isValid__iC"></span><span class="target" id="classpcl_1_1_range_image_1ad353c062c9b17adda3797bf970b9934b"></span>bool <code class="sig-name descname">isValid</code><span class="sig-paren">(</span>int <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage7isValidEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a point has a finite range. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage10isObservedEii">
<span id="_CPPv3NK3pcl10RangeImage10isObservedEii"></span><span id="_CPPv2NK3pcl10RangeImage10isObservedEii"></span><span id="pcl::RangeImage::isObserved__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a75e51885e151759d815ec1b1b72ea4ff"></span>bool <code class="sig-name descname">isObserved</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage10isObservedEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a point is inside of the image and has either a finite range or a max reading (range=INFINITY) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage10isMaxRangeEii">
<span id="_CPPv3NK3pcl10RangeImage10isMaxRangeEii"></span><span id="_CPPv2NK3pcl10RangeImage10isMaxRangeEii"></span><span id="pcl::RangeImage::isMaxRange__i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a771ab2f1ee2952a319da20301b27ab3b"></span>bool <code class="sig-name descname">isMaxRange</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage10isMaxRangeEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a point is a max range (range=INFINITY) - please check isInImage or isObserved first! </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage9getNormalEiiiRN5Eigen8Vector3fEi">
<span id="_CPPv3NK3pcl10RangeImage9getNormalEiiiRN5Eigen8Vector3fEi"></span><span id="_CPPv2NK3pcl10RangeImage9getNormalEiiiRN5Eigen8Vector3fEi"></span><span id="pcl::RangeImage::getNormal__i.i.i.Eigen::Vector3fR.iC"></span><span class="target" id="classpcl_1_1_range_image_1aeb21e9a192704802adabd6693f00e397"></span>bool <code class="sig-name descname">getNormal</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, Eigen::Vector3f &amp;<em>normal</em>, int <em>step_size</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage9getNormalEiiiRN5Eigen8Vector3fEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the normal of an image point using the neighbors with a maximum pixel distance of radius. </p>
<p>step_size determines how many pixels are used. 1 means all, 2 only every second, etc.. Returns false if it was unable to calculate a normal. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRK14PointWithRangeiRN5Eigen8Vector3fEi">
<span id="_CPPv3NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRK14PointWithRangeiRN5Eigen8Vector3fEi"></span><span id="_CPPv2NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRK14PointWithRangeiRN5Eigen8Vector3fEi"></span><span id="pcl::RangeImage::getNormalForClosestNeighbors__i.i.i.PointWithRangeCR.i.Eigen::Vector3fR.iC"></span><span class="target" id="classpcl_1_1_range_image_1accb0781e43e55cff62851019ffac47ce"></span>bool <code class="sig-name descname">getNormalForClosestNeighbors</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, <em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point</em>, int <em>no_of_nearest_neighbors</em>, Eigen::Vector3f &amp;<em>normal</em>, int <em>step_size</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRK14PointWithRangeiRN5Eigen8Vector3fEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above, but only the no_of_nearest_neighbors points closest to the given point are considered. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRKN5Eigen8Vector3fEiRN5Eigen8Vector3fEPN5Eigen8Vector3fEi">
<span id="_CPPv3NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRKN5Eigen8Vector3fEiRN5Eigen8Vector3fEPN5Eigen8Vector3fEi"></span><span id="_CPPv2NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRKN5Eigen8Vector3fEiRN5Eigen8Vector3fEPN5Eigen8Vector3fEi"></span><span id="pcl::RangeImage::getNormalForClosestNeighbors__i.i.i.Eigen::Vector3fCR.i.Eigen::Vector3fR.Eigen::Vector3fP.iC"></span><span class="target" id="classpcl_1_1_range_image_1a2de7a8f331c28ac81440ba74e56369bc"></span>bool <code class="sig-name descname">getNormalForClosestNeighbors</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, <em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, int <em>no_of_nearest_neighbors</em>, Eigen::Vector3f &amp;<em>normal</em>, Eigen::Vector3f *<em>point_on_plane</em> = NULL, int <em>step_size</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiiRKN5Eigen8Vector3fEiRN5Eigen8Vector3fEPN5Eigen8Vector3fEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiRN5Eigen8Vector3fEi">
<span id="_CPPv3NK3pcl10RangeImage28getNormalForClosestNeighborsEiiRN5Eigen8Vector3fEi"></span><span id="_CPPv2NK3pcl10RangeImage28getNormalForClosestNeighborsEiiRN5Eigen8Vector3fEi"></span><span id="pcl::RangeImage::getNormalForClosestNeighbors__i.i.Eigen::Vector3fR.iC"></span><span class="target" id="classpcl_1_1_range_image_1a5cb82433197f15970647793c6271fe9a"></span>bool <code class="sig-name descname">getNormalForClosestNeighbors</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, Eigen::Vector3f &amp;<em>normal</em>, int <em>radius</em> = 2<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage28getNormalForClosestNeighborsEiiRN5Eigen8Vector3fEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above, using default values. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage21getSurfaceInformationEiiiRKN5Eigen8Vector3fEiiRfRN5Eigen8Vector3fERN5Eigen8Vector3fERN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage21getSurfaceInformationEiiiRKN5Eigen8Vector3fEiiRfRN5Eigen8Vector3fERN5Eigen8Vector3fERN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage21getSurfaceInformationEiiiRKN5Eigen8Vector3fEiiRfRN5Eigen8Vector3fERN5Eigen8Vector3fERN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getSurfaceInformation__i.i.i.Eigen::Vector3fCR.i.i.floatR.Eigen::Vector3fR.Eigen::Vector3fR.Eigen::Vector3fR.Eigen::Vector3fP.Eigen::Vector3fP.Eigen::Vector3fPC"></span><span class="target" id="classpcl_1_1_range_image_1abf1ce91a6aae13aefb5d3026273eb108"></span>bool <code class="sig-name descname">getSurfaceInformation</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, <em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, int <em>no_of_closest_neighbors</em>, int <em>step_size</em>, float &amp;<em>max_closest_neighbor_distance_squared</em>, Eigen::Vector3f &amp;<em>normal</em>, Eigen::Vector3f &amp;<em>mean</em>, Eigen::Vector3f &amp;<em>eigen_values</em>, Eigen::Vector3f *<em>normal_all_neighbors</em> = NULL, Eigen::Vector3f *<em>mean_all_neighbors</em> = NULL, Eigen::Vector3f *<em>eigen_values_all_neighbors</em> = NULL<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage21getSurfaceInformationEiiiRKN5Eigen8Vector3fEiiRfRN5Eigen8Vector3fERN5Eigen8Vector3fERN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fEPN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above but extracts some more data and can also return the extracted information for all neighbors in radius if normal_all_neighbors is not NULL. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage31getSquaredDistanceOfNthNeighborEiiiii">
<span id="_CPPv3NK3pcl10RangeImage31getSquaredDistanceOfNthNeighborEiiiii"></span><span id="_CPPv2NK3pcl10RangeImage31getSquaredDistanceOfNthNeighborEiiiii"></span><span id="pcl::RangeImage::getSquaredDistanceOfNthNeighbor__i.i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1ae259a9342238404e8dbb3ff938470ce2"></span>float <code class="sig-name descname">getSquaredDistanceOfNthNeighbor</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, int <em>n</em>, int <em>step_size</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage31getSquaredDistanceOfNthNeighborEiiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage14getImpactAngleERK14PointWithRangeRK14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage14getImpactAngleERK14PointWithRangeRK14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage14getImpactAngleERK14PointWithRangeRK14PointWithRange"></span><span id="pcl::RangeImage::getImpactAngle__PointWithRangeCR.PointWithRangeCRC"></span><span class="target" id="classpcl_1_1_range_image_1a6b87fa04fd32ec986f1af9149bd46841"></span>float <code class="sig-name descname">getImpactAngle</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point1</em>, <em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage14getImpactAngleERK14PointWithRangeRK14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the impact angle based on the sensor position and the two given points - will return -INFINITY if one of the points is unobserved. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage14getImpactAngleEiiii">
<span id="_CPPv3NK3pcl10RangeImage14getImpactAngleEiiii"></span><span id="_CPPv2NK3pcl10RangeImage14getImpactAngleEiiii"></span><span id="pcl::RangeImage::getImpactAngle__i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1aa6210710d430006d4c4ca93b6f8023da"></span>float <code class="sig-name descname">getImpactAngle</code><span class="sig-paren">(</span>int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage14getImpactAngleEiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage32getImpactAngleBasedOnLocalNormalEiii">
<span id="_CPPv3NK3pcl10RangeImage32getImpactAngleBasedOnLocalNormalEiii"></span><span id="_CPPv2NK3pcl10RangeImage32getImpactAngleBasedOnLocalNormalEiii"></span><span id="pcl::RangeImage::getImpactAngleBasedOnLocalNormal__i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a1ca716a0e6b2aba846bdb4079275f6d9"></span>float <code class="sig-name descname">getImpactAngleBasedOnLocalNormal</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage32getImpactAngleBasedOnLocalNormalEiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract a local normal (with a heuristic not to include background points) and calculate the impact angle based on this. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1aecd52c29445543d03e40f0d75c8120c0"></span><code class="sig-name descname">PCL_EXPORTS float* pcl::RangeImage::getImpactAngleImageBasedOnLocalNormals(int radius) const</code></dt>
<dd><p>Uses the above function for every point in the image. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage28getNormalBasedAcutenessValueEiii">
<span id="_CPPv3NK3pcl10RangeImage28getNormalBasedAcutenessValueEiii"></span><span id="_CPPv2NK3pcl10RangeImage28getNormalBasedAcutenessValueEiii"></span><span id="pcl::RangeImage::getNormalBasedAcutenessValue__i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a5b6d4bb74fa5134a6c21823dfdcdb13e"></span>float <code class="sig-name descname">getNormalBasedAcutenessValue</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage28getNormalBasedAcutenessValueEiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) This uses getImpactAngleBasedOnLocalNormal Will return -INFINITY if no normal could be calculated. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage17getAcutenessValueERK14PointWithRangeRK14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage17getAcutenessValueERK14PointWithRangeRK14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage17getAcutenessValueERK14PointWithRangeRK14PointWithRange"></span><span id="pcl::RangeImage::getAcutenessValue__PointWithRangeCR.PointWithRangeCRC"></span><span class="target" id="classpcl_1_1_range_image_1a2290765b8ccd5608ffa4967dc282395a"></span>float <code class="sig-name descname">getAcutenessValue</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point1</em>, <em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage17getAcutenessValueERK14PointWithRangeRK14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) will return -INFINITY if one of the points is unobserved. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage17getAcutenessValueEiiii">
<span id="_CPPv3NK3pcl10RangeImage17getAcutenessValueEiiii"></span><span id="_CPPv2NK3pcl10RangeImage17getAcutenessValueEiiii"></span><span id="pcl::RangeImage::getAcutenessValue__i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a428803af781c88a43cf0c9b251d081bf"></span>float <code class="sig-name descname">getAcutenessValue</code><span class="sig-paren">(</span>int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage17getAcutenessValueEiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a56821ed68e8701450b4725ed9c6fd7a0"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getAcutenessValueImages(int pixel_distance, float *&amp; acuteness_value_image_x, float *&amp; acuteness_value_image_y) const</code></dt>
<dd><p>Calculate getAcutenessValue for every point. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a16b744103dab2ba2a9ada137aa75887f"></span><code class="sig-name descname">PCL_EXPORTS float pcl::RangeImage::getSurfaceChange(int x, int y, int radius) const</code></dt>
<dd><p>Calculates, how much the surface changes at a point. </p>
<p>Pi meaning a flat suface and 0.0f would be a needle point Calculates, how much the surface changes at a point. 1 meaning a 90deg angle and 0 a flat suface </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a23b27f51c94a493a2c98c96a6acf3f11"></span><code class="sig-name descname">PCL_EXPORTS float* pcl::RangeImage::getSurfaceChangeImage(int radius) const</code></dt>
<dd><p>Uses the above function for every point in the image. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage21getSurfaceAngleChangeEiiiRfRf">
<span id="_CPPv3NK3pcl10RangeImage21getSurfaceAngleChangeEiiiRfRf"></span><span id="_CPPv2NK3pcl10RangeImage21getSurfaceAngleChangeEiiiRfRf"></span><span id="pcl::RangeImage::getSurfaceAngleChange__i.i.i.floatR.floatRC"></span><span class="target" id="classpcl_1_1_range_image_1afd94afe865f6cd46cfbc64f45bb1d03e"></span>void <code class="sig-name descname">getSurfaceAngleChange</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, float &amp;<em>angle_change_x</em>, float &amp;<em>angle_change_y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage21getSurfaceAngleChangeEiiiRfRf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculates, how much the surface changes at a point. </p>
<p>Returns an angle [0.0f, PI] for x and y direction. A return value of -INFINITY means that a point was unobserved. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a0501e4697fe05327423b4e247baa3528"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getSurfaceAngleChangeImages(int radius, float *&amp; angle_change_image_x, float *&amp; angle_change_image_y) const</code></dt>
<dd><p>Uses the above function for every point in the image. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage12getCurvatureEiiii">
<span id="_CPPv3NK3pcl10RangeImage12getCurvatureEiiii"></span><span id="_CPPv2NK3pcl10RangeImage12getCurvatureEiiii"></span><span id="pcl::RangeImage::getCurvature__i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1ac6a22e10be8bfcedf9297d1e1badef1c"></span>float <code class="sig-name descname">getCurvature</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>radius</em>, int <em>step_size</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage12getCurvatureEiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculates the curvature in a point using pca. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage12getSensorPosEv">
<span id="_CPPv3NK3pcl10RangeImage12getSensorPosEv"></span><span id="_CPPv2NK3pcl10RangeImage12getSensorPosEv"></span><span id="pcl::RangeImage::getSensorPosC"></span><span class="target" id="classpcl_1_1_range_image_1a942d6b253c5df68008614af6dfed323a"></span><em class="property">const</em> Eigen::Vector3f <code class="sig-name descname">getSensorPos</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage12getSensorPosEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the sensor position. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1ad4f7d854c4f15ab0ab2193cc726c353f"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::setUnseenToMaxRange()</code></dt>
<dd><p>Sets all -INFINITY values to INFINITY. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage15getImageOffsetXEv">
<span id="_CPPv3NK3pcl10RangeImage15getImageOffsetXEv"></span><span id="_CPPv2NK3pcl10RangeImage15getImageOffsetXEv"></span><span id="pcl::RangeImage::getImageOffsetXC"></span><span class="target" id="classpcl_1_1_range_image_1a25e2db660717d67a19f5cdb39937c00a"></span>int <code class="sig-name descname">getImageOffsetX</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage15getImageOffsetXEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for image_offset_x_. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage15getImageOffsetYEv">
<span id="_CPPv3NK3pcl10RangeImage15getImageOffsetYEv"></span><span id="_CPPv2NK3pcl10RangeImage15getImageOffsetYEv"></span><span id="pcl::RangeImage::getImageOffsetYC"></span><span class="target" id="classpcl_1_1_range_image_1a42c06aa5693077ab6db7ec5c691dc677"></span>int <code class="sig-name descname">getImageOffsetY</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage15getImageOffsetYEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Getter for image_offset_y_. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage15setImageOffsetsEii">
<span id="_CPPv3N3pcl10RangeImage15setImageOffsetsEii"></span><span id="_CPPv2N3pcl10RangeImage15setImageOffsetsEii"></span><span id="pcl::RangeImage::setImageOffsets__i.i"></span><span class="target" id="classpcl_1_1_range_image_1a962a922e6a1170b1494ee21859087b4e"></span>void <code class="sig-name descname">setImageOffsets</code><span class="sig-paren">(</span>int <em>offset_x</em>, int <em>offset_y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15setImageOffsetsEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Setter for image offsets. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage11getSubImageEiiiiiR10RangeImage">
<span id="_CPPv3NK3pcl10RangeImage11getSubImageEiiiiiR10RangeImage"></span><span id="_CPPv2NK3pcl10RangeImage11getSubImageEiiiiiR10RangeImage"></span><span id="pcl::RangeImage::getSubImage__i.i.i.i.i.RangeImageRC"></span><span class="target" id="classpcl_1_1_range_image_1a33f4985713cf3f17ac8f8c69c0201729"></span><em class="property">virtual</em> void <code class="sig-name descname">getSubImage</code><span class="sig-paren">(</span>int <em>sub_image_image_offset_x</em>, int <em>sub_image_image_offset_y</em>, int <em>sub_image_width</em>, int <em>sub_image_height</em>, int <em>combine_pixels</em>, <a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a> &amp;<em>sub_image</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage11getSubImageEiiiiiR10RangeImage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a sub part of the complete image as a new range image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sub_image_image_offset_x</span></code>: - The x coordinate of the top left pixel of the sub image. This is always according to absolute 0,0 meaning -180°,-90° and it is already in the system of the new image, so the actual pixel used in the original image is combine_pixels* (image_offset_x-image_offset_x_) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_image_image_offset_y</span></code>: - Same as image_offset_x for the y coordinate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_image_width</span></code>: - width of the new image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_image_height</span></code>: - height of the new image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">combine_pixels</span></code>: - shrinking factor, meaning the new angular resolution is combine_pixels times the old one </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_image</span></code>: - the output image </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage12getHalfImageER10RangeImage">
<span id="_CPPv3NK3pcl10RangeImage12getHalfImageER10RangeImage"></span><span id="_CPPv2NK3pcl10RangeImage12getHalfImageER10RangeImage"></span><span id="pcl::RangeImage::getHalfImage__RangeImageRC"></span><span class="target" id="classpcl_1_1_range_image_1ab39a4eac61ba75bb9f2913a1ff3ec84d"></span><em class="property">virtual</em> void <code class="sig-name descname">getHalfImage</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3pcl10RangeImageE" title="pcl::RangeImage">RangeImage</a> &amp;<em>half_image</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage12getHalfImageER10RangeImage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a range image with half the resolution. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a83b475eb983cd9edaea5d97c6d098a7c"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getMinMaxRanges(float &amp; min_range, float &amp; max_range) const</code></dt>
<dd><p>Find the minimum and maximum range in the image. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a37582520baf6b317bbb81e85c95cc602"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::change3dPointsToLocalCoordinateFrame()</code></dt>
<dd><p>This function sets the sensor pose to 0 and transforms all point positions to this local coordinate frame. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a225cab091b80ff23a3c7b0d7291dead2"></span><code class="sig-name descname">PCL_EXPORTS float* pcl::RangeImage::getInterpolatedSurfaceProjection(const Eigen::Affine3f &amp; pose, int pixel_size, float world_size) const</code></dt>
<dd><p>Calculate a range patch as the z values of the coordinate frame given by pose. </p>
<p>The patch will have size pixel_size x pixel_size and each pixel covers world_size/pixel_size meters in the world You are responsible for deleting the structure afterwards! </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1accadf69890d534cfcb0f9d65c60feaac"></span><code class="sig-name descname">PCL_EXPORTS float* pcl::RangeImage::getInterpolatedSurfaceProjection(const Eigen::Vector3f &amp; point, int pixel_size, float world_size) const</code></dt>
<dd><p>Same as above, but using the local coordinate frame defined by point and the viewing direction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getTransformationToViewerCoordinateFrame__Eigen::Vector3fCRC"></span><span class="target" id="classpcl_1_1_range_image_1a6646c58459dc6780f114039d296d88d4"></span>Eigen::Affine3f <code class="sig-name descname">getTransformationToViewerCoordinateFrame</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the local coordinate frame with 0,0,0 in point, upright and Z as the viewing direction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE">
<span id="_CPPv3NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE"></span><span id="_CPPv2NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE"></span><span id="pcl::RangeImage::getTransformationToViewerCoordinateFrame__Eigen::Vector3fCR.Eigen::Affine3fRC"></span><span class="target" id="classpcl_1_1_range_image_1a4f79a45cb9beea2cca3a6f17a16d44b7"></span>void <code class="sig-name descname">getTransformationToViewerCoordinateFrame</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, Eigen::Affine3f &amp;<em>transformation</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage40getTransformationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above, using a reference for the retrurn value. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage34getRotationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE">
<span id="_CPPv3NK3pcl10RangeImage34getRotationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE"></span><span id="_CPPv2NK3pcl10RangeImage34getRotationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE"></span><span id="pcl::RangeImage::getRotationToViewerCoordinateFrame__Eigen::Vector3fCR.Eigen::Affine3fRC"></span><span class="target" id="classpcl_1_1_range_image_1ab38c579faf678914119d4190b0068ab6"></span>void <code class="sig-name descname">getRotationToViewerCoordinateFrame</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, Eigen::Affine3f &amp;<em>transformation</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage34getRotationToViewerCoordinateFrameERKN5Eigen8Vector3fERN5Eigen8Affine3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as above, but only returning the rotation. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a0ee070d08d3e3688e24f8ebffc9b6436"></span><code class="sig-name descname">PCL_EXPORTS bool pcl::RangeImage::getNormalBasedUprightTransformation(const Eigen::Vector3f &amp; point, float max_dist, Eigen::Affine3f &amp; transformation) const</code></dt>
<dd><p>Get a local coordinate frame at the given point based on the normal. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a03e02f341db8f43860b2cb83824a2123"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getIntegralImage(float *&amp; integral_image, int *&amp; valid_points_num_image) const</code></dt>
<dd><p>Get the integral image of the range values (used for fast blur operations). </p>
<p>You are responsible for deleting it after usage! </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a1037c5597389ad0f981c91f820b392a9"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getBlurredImageUsingIntegralImage(int blur_radius, float * integral_image, int * valid_points_num_image, RangeImage  &amp; range_image) const</code></dt>
<dd><p>Get a blurred version of the range image using box filters on the provided integral image. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a29b238256cffb27a526bf89e857e5602"></span><code class="sig-name descname">virtual PCL_EXPORTS void pcl::RangeImage::getBlurredImage(int blur_radius, RangeImage  &amp; range_image) const</code></dt>
<dd><p>Get a blurred version of the range image using box filters. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage27getEuclideanDistanceSquaredEiiii">
<span id="_CPPv3NK3pcl10RangeImage27getEuclideanDistanceSquaredEiiii"></span><span id="_CPPv2NK3pcl10RangeImage27getEuclideanDistanceSquaredEiiii"></span><span id="pcl::RangeImage::getEuclideanDistanceSquared__i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a9270139a4ebc5b01e91262bba72c1cf5"></span>float <code class="sig-name descname">getEuclideanDistanceSquared</code><span class="sig-paren">(</span>int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage27getEuclideanDistanceSquaredEiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the squared euclidean distance between the two image points. </p>
<p>Returns -INFINITY if one of the points was not observed </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage27getAverageEuclideanDistanceEiiiii">
<span id="_CPPv3NK3pcl10RangeImage27getAverageEuclideanDistanceEiiiii"></span><span id="_CPPv2NK3pcl10RangeImage27getAverageEuclideanDistanceEiiiii"></span><span id="pcl::RangeImage::getAverageEuclideanDistance__i.i.i.i.iC"></span><span class="target" id="classpcl_1_1_range_image_1a4d702bb8f446bb382040e5872b6dbfb1"></span>float <code class="sig-name descname">getAverageEuclideanDistance</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>offset_x</em>, int <em>offset_y</em>, int <em>max_steps</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage27getAverageEuclideanDistanceEiiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Doing the above for some steps in the given direction and averaging. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a42e94ffae804608d0a7d2762cddd6fd2"></span><code class="sig-name descname">PCL_EXPORTS void pcl::RangeImage::getRangeImageWithSmoothedSurface(int radius, RangeImage  &amp; smoothed_range_image) const</code></dt>
<dd><p>Project all points on the local plane approximation, thereby smoothing the surface of the scan. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage17get1dPointAverageEiiiiiR14PointWithRange">
<span id="_CPPv3NK3pcl10RangeImage17get1dPointAverageEiiiiiR14PointWithRange"></span><span id="_CPPv2NK3pcl10RangeImage17get1dPointAverageEiiiiiR14PointWithRange"></span><span id="pcl::RangeImage::get1dPointAverage__i.i.i.i.i.PointWithRangeRC"></span><span class="target" id="classpcl_1_1_range_image_1a397d6c6b38906e98ab89b817c4191247"></span>void <code class="sig-name descname">get1dPointAverage</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, int <em>delta_x</em>, int <em>delta_y</em>, int <em>no_of_points</em>, <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>average_point</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage17get1dPointAverageEiiiiiR14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculates the average 3D position of the no_of_points points described by the start point x,y in the direction delta. </p>
<p>Returns a max range point (range=INFINITY) if the first point is max range and an unobserved point (range=-INFINITY) if non of the points is observed. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1addd0bcec3d51c70ac205bbfc75dd8c18"></span><code class="sig-name descname">PCL_EXPORTS float pcl::RangeImage::getOverlap(const  RangeImage  &amp; other_range_image, const Eigen::Affine3f &amp; relative_transformation, int search_radius, float max_distance, int pixel_step = 1) const</code></dt>
<dd><p>Calculates the overlap of two range images given the relative transformation (from the given image to *this) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage19getViewingDirectionEiiRN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage19getViewingDirectionEiiRN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage19getViewingDirectionEiiRN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getViewingDirection__i.i.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1ad37bc4a8aab3d63ee7c9ef9428239f00"></span>bool <code class="sig-name descname">getViewingDirection</code><span class="sig-paren">(</span>int <em>x</em>, int <em>y</em>, Eigen::Vector3f &amp;<em>viewing_direction</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage19getViewingDirectionEiiRN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the viewing direction for the given point. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK3pcl10RangeImage19getViewingDirectionERKN5Eigen8Vector3fERN5Eigen8Vector3fE">
<span id="_CPPv3NK3pcl10RangeImage19getViewingDirectionERKN5Eigen8Vector3fERN5Eigen8Vector3fE"></span><span id="_CPPv2NK3pcl10RangeImage19getViewingDirectionERKN5Eigen8Vector3fERN5Eigen8Vector3fE"></span><span id="pcl::RangeImage::getViewingDirection__Eigen::Vector3fCR.Eigen::Vector3fRC"></span><span class="target" id="classpcl_1_1_range_image_1a32dfa3c681a50aebc74ae6830767a831"></span>void <code class="sig-name descname">getViewingDirection</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Vector3f &amp;<em>point</em>, Eigen::Vector3f &amp;<em>viewing_direction</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3pcl10RangeImage19getViewingDirectionERKN5Eigen8Vector3fERN5Eigen8Vector3fE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the viewing direction for the given point. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a7bca09c1eb8be12975c47cb6d6233ca5"></span><code class="sig-name descname">virtual PCL_EXPORTS RangeImage* pcl::RangeImage::getNew() const</code></dt>
<dd><p>Return a newly created Range image. </p>
<p>Can be reimplemented in derived classes like <a class="reference internal" href="classpcl_1_1_range_image_planar.html#classpcl_1_1_range_image_planar"><span class="std std-ref">RangeImagePlanar</span></a> to return an image of the same type. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a454c9018fc001c85e9d8df6900ceb0f6"></span><code class="sig-name descname">virtual PCL_EXPORTS void pcl::RangeImage::copyTo(RangeImage  &amp; other) const</code></dt>
<dd><p>Copy other to *this. </p>
<p>Necessary for use in virtual functions that need to copy derived <a class="reference internal" href="#classpcl_1_1_range_image"><span class="std std-ref">RangeImage</span></a> classes (like <a class="reference internal" href="classpcl_1_1_range_image_planar.html#classpcl_1_1_range_image_planar"><span class="std std-ref">RangeImagePlanar</span></a>) </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage15getMaxAngleSizeERKN5Eigen8Affine3fERKN5Eigen8Vector3fEf">
<span id="_CPPv3N3pcl10RangeImage15getMaxAngleSizeERKN5Eigen8Affine3fERKN5Eigen8Vector3fEf"></span><span id="_CPPv2N3pcl10RangeImage15getMaxAngleSizeERKN5Eigen8Affine3fERKN5Eigen8Vector3fEf"></span><span id="pcl::RangeImage::getMaxAngleSize__Eigen::Affine3fCR.Eigen::Vector3fCR.float"></span><span class="target" id="classpcl_1_1_range_image_1ac504743608967dcd142dc4249b82ea5a"></span>float <code class="sig-name descname">getMaxAngleSize</code><span class="sig-paren">(</span><em class="property">const</em> Eigen::Affine3f &amp;<em>viewer_pose</em>, <em class="property">const</em> Eigen::Vector3f &amp;<em>center</em>, float <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15getMaxAngleSizeERKN5Eigen8Affine3fERKN5Eigen8Vector3fEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the size of a certain area when seen from the given pose. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the size of the area as viewed according to <em>viewer_pose</em> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">viewer_pose</span></code>: an affine matrix defining the pose of the viewer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">center</span></code>: the center of the area </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radius</span></code>: the radius of the area </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage16getEigenVector3fERK14PointWithRange">
<span id="_CPPv3N3pcl10RangeImage16getEigenVector3fERK14PointWithRange"></span><span id="_CPPv2N3pcl10RangeImage16getEigenVector3fERK14PointWithRange"></span><span id="pcl::RangeImage::getEigenVector3f__PointWithRangeCR"></span><span class="target" id="classpcl_1_1_range_image_1a2e3b75077a96415e431b90f53a249773"></span>Eigen::Vector3f <code class="sig-name descname">getEigenVector3f</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> &amp;<em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage16getEigenVector3fERK14PointWithRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Eigen::Vector3f from <a class="reference internal" href="structpcl_1_1_point_with_range.html#structpcl_1_1_point_with_range"><span class="std std-ref">PointWithRange</span></a>. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an Eigen::Vector3f representation of the input point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point</span></code>: the input point </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1af5c0908bfbe060fdb517728fe56b2c55"></span><code class="sig-name descname">static PCL_EXPORTS void pcl::RangeImage::getCoordinateFrameTransformation(RangeImage::CoordinateFrame coordinate_frame, Eigen::Affine3f &amp; transformation)</code></dt>
<dd><p>Get the transformation that transforms the given coordinate frame into CAMERA_FRAME. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">coordinate_frame</span></code>: the input coordinate frame </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transformation</span></code>: the resulting transformation that warps <em>coordinate_frame</em> into CAMERA_FRAME </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN3pcl10RangeImage19getAverageViewPointEN5Eigen8Vector3fERK28PointCloudTypeWithViewpoints">
<span id="_CPPv3I0EN3pcl10RangeImage19getAverageViewPointERK28PointCloudTypeWithViewpoints"></span><span id="_CPPv2I0EN3pcl10RangeImage19getAverageViewPointERK28PointCloudTypeWithViewpoints"></span><span class="target" id="classpcl_1_1_range_image_1a49c425d518d92def18300cd029ae1855"></span>template&lt;typename <code class="sig-name descname">PointCloudTypeWithViewpoints</code>&gt;<br />Eigen::Vector3f <code class="sig-name descname">getAverageViewPoint</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3pcl10RangeImage19getAverageViewPointEN5Eigen8Vector3fERK28PointCloudTypeWithViewpoints" title="pcl::RangeImage::getAverageViewPoint::PointCloudTypeWithViewpoints">PointCloudTypeWithViewpoints</a> &amp;<em>point_cloud</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3pcl10RangeImage19getAverageViewPointEN5Eigen8Vector3fERK28PointCloudTypeWithViewpoints" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the average viewpoint of a point cloud where each point carries viewpoint information as vp_x, vp_y, vp_z. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the average viewpoint (as an Eigen::Vector3f) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud</span></code>: the input point cloud </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="classpcl_1_1_range_image_1a75e39ee2587a56fbdda651c27cc7898e"></span><code class="sig-name descname">static PCL_EXPORTS void pcl::RangeImage::extractFarRanges(const  pcl::PCLPointCloud2  &amp; point_cloud_data, PointCloud &lt;  PointWithViewpoint  &gt; &amp; far_ranges)</code></dt>
<dd><p>Check if the provided data includes far ranges and add them to far_ranges. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">point_cloud_data</span></code>: a <a class="reference internal" href="structpcl_1_1_p_c_l_point_cloud2.html#structpcl_1_1_p_c_l_point_cloud2"><span class="std std-ref">PCLPointCloud2</span></a> message containing the input cloud </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">far_ranges</span></code>: the resulting cloud containing those points with far ranges </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Attributes</p>
<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage17max_no_of_threadsE">
<span id="_CPPv3N3pcl10RangeImage17max_no_of_threadsE"></span><span id="_CPPv2N3pcl10RangeImage17max_no_of_threadsE"></span><span id="pcl::RangeImage::max_no_of_threads__i"></span><span class="target" id="classpcl_1_1_range_image_1a34fe4f6701548e2514ae45099309cac4"></span>int <code class="sig-name descname">max_no_of_threads</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage17max_no_of_threadsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The maximum number of openmp threads that can be used in this class. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage5debugE">
<span id="_CPPv3N3pcl10RangeImage5debugE"></span><span id="_CPPv2N3pcl10RangeImage5debugE"></span><span id="pcl::RangeImage::debug__b"></span><span class="target" id="classpcl_1_1_range_image_1a1bd552e2971d69843fdec72413823f57"></span>bool <code class="sig-name descname">debug</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage5debugE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Just for… </p>
<p>well… debugging purposes. :-) </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Protected Attributes</p>
<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage22to_range_image_system_E">
<span id="_CPPv3N3pcl10RangeImage22to_range_image_system_E"></span><span id="_CPPv2N3pcl10RangeImage22to_range_image_system_E"></span><span id="pcl::RangeImage::to_range_image_system___Eigen::Affine3f"></span><span class="target" id="classpcl_1_1_range_image_1ada8177479f0e95999a66294db4c0c3eb"></span>Eigen::Affine3f <code class="sig-name descname">to_range_image_system_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage22to_range_image_system_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inverse of to_world_system_. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage16to_world_system_E">
<span id="_CPPv3N3pcl10RangeImage16to_world_system_E"></span><span id="_CPPv2N3pcl10RangeImage16to_world_system_E"></span><span id="pcl::RangeImage::to_world_system___Eigen::Affine3f"></span><span class="target" id="classpcl_1_1_range_image_1a31c36f147403c0f64e1c3a386b30e229"></span>Eigen::Affine3f <code class="sig-name descname">to_world_system_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage16to_world_system_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inverse of to_range_image_system_. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage21angular_resolution_x_E">
<span id="_CPPv3N3pcl10RangeImage21angular_resolution_x_E"></span><span id="_CPPv2N3pcl10RangeImage21angular_resolution_x_E"></span><span id="pcl::RangeImage::angular_resolution_x___float"></span><span class="target" id="classpcl_1_1_range_image_1abdbfb655cdfeb5d8ace1ac841a52a524"></span>float <code class="sig-name descname">angular_resolution_x_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage21angular_resolution_x_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angular resolution of the range image in x direction in radians per pixel. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage21angular_resolution_y_E">
<span id="_CPPv3N3pcl10RangeImage21angular_resolution_y_E"></span><span id="_CPPv2N3pcl10RangeImage21angular_resolution_y_E"></span><span id="pcl::RangeImage::angular_resolution_y___float"></span><span class="target" id="classpcl_1_1_range_image_1a9471a00ecde65c754227e155cc234942"></span>float <code class="sig-name descname">angular_resolution_y_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage21angular_resolution_y_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angular resolution of the range image in y direction in radians per pixel. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage32angular_resolution_x_reciprocal_E">
<span id="_CPPv3N3pcl10RangeImage32angular_resolution_x_reciprocal_E"></span><span id="_CPPv2N3pcl10RangeImage32angular_resolution_x_reciprocal_E"></span><span id="pcl::RangeImage::angular_resolution_x_reciprocal___float"></span><span class="target" id="classpcl_1_1_range_image_1adbb1466576e6c2d08e3065b67da0b250"></span>float <code class="sig-name descname">angular_resolution_x_reciprocal_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage32angular_resolution_x_reciprocal_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>1.0/angular_resolution_x_ - provided for better performance of multiplication compared to division </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage32angular_resolution_y_reciprocal_E">
<span id="_CPPv3N3pcl10RangeImage32angular_resolution_y_reciprocal_E"></span><span id="_CPPv2N3pcl10RangeImage32angular_resolution_y_reciprocal_E"></span><span id="pcl::RangeImage::angular_resolution_y_reciprocal___float"></span><span class="target" id="classpcl_1_1_range_image_1a843659230146a43690ee4d4fb53fcc92"></span>float <code class="sig-name descname">angular_resolution_y_reciprocal_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage32angular_resolution_y_reciprocal_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>1.0/angular_resolution_y_ - provided for better performance of multiplication compared to division </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage15image_offset_x_E">
<span id="_CPPv3N3pcl10RangeImage15image_offset_x_E"></span><span id="_CPPv2N3pcl10RangeImage15image_offset_x_E"></span><span id="pcl::RangeImage::image_offset_x___i"></span><span class="target" id="classpcl_1_1_range_image_1ac01b76b2e83df5967984084e7558c2d5"></span>int <code class="sig-name descname">image_offset_x_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15image_offset_x_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage15image_offset_y_E">
<span id="_CPPv3N3pcl10RangeImage15image_offset_y_E"></span><span id="_CPPv2N3pcl10RangeImage15image_offset_y_E"></span><span id="pcl::RangeImage::image_offset_y___i"></span><span class="target" id="classpcl_1_1_range_image_1a1518af9f1c9eb6ac259be92824842e23"></span>int <code class="sig-name descname">image_offset_y_</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage15image_offset_y_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Position of the top left corner of the range image compared to an image of full size (360x180 degrees) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage16unobserved_pointE">
<span id="_CPPv3N3pcl10RangeImage16unobserved_pointE"></span><span id="_CPPv2N3pcl10RangeImage16unobserved_pointE"></span><span id="pcl::RangeImage::unobserved_point__PointWithRange"></span><span class="target" id="classpcl_1_1_range_image_1a51bf019906a3256038561354d6b95885"></span><a class="reference internal" href="structpcl_1_1_point_with_range.html#_CPPv4N3pcl14PointWithRangeE" title="pcl::PointWithRange">PointWithRange</a> <code class="sig-name descname">unobserved_point</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage16unobserved_pointE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This point is used to be able to return a reference to a non-existing point. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Protected Static Functions</p>
<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage18createLookupTablesEv">
<span id="_CPPv3N3pcl10RangeImage18createLookupTablesEv"></span><span id="_CPPv2N3pcl10RangeImage18createLookupTablesEv"></span><span id="pcl::RangeImage::createLookupTables"></span><span class="target" id="classpcl_1_1_range_image_1ae74c34594e1417fb702d92ff51f2b495"></span><em class="property">static</em> void <code class="sig-name descname">createLookupTables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage18createLookupTablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create lookup tables for trigonometric functions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage10asinLookUpEf">
<span id="_CPPv3N3pcl10RangeImage10asinLookUpEf"></span><span id="_CPPv2N3pcl10RangeImage10asinLookUpEf"></span><span id="pcl::RangeImage::asinLookUp__float"></span><span class="target" id="classpcl_1_1_range_image_1a6cb20514cdc04674448a5e5c6cb373bc"></span>float <code class="sig-name descname">asinLookUp</code><span class="sig-paren">(</span>float <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage10asinLookUpEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Query the asin lookup table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage11atan2LookUpEff">
<span id="_CPPv3N3pcl10RangeImage11atan2LookUpEff"></span><span id="_CPPv2N3pcl10RangeImage11atan2LookUpEff"></span><span id="pcl::RangeImage::atan2LookUp__float.float"></span><span class="target" id="classpcl_1_1_range_image_1a17835570c515cca3ba1ecd0f132bf013"></span>float <code class="sig-name descname">atan2LookUp</code><span class="sig-paren">(</span>float <em>y</em>, float <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage11atan2LookUpEff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Query the atan2 lookup table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N3pcl10RangeImage9cosLookUpEf">
<span id="_CPPv3N3pcl10RangeImage9cosLookUpEf"></span><span id="_CPPv2N3pcl10RangeImage9cosLookUpEf"></span><span id="pcl::RangeImage::cosLookUp__float"></span><span class="target" id="classpcl_1_1_range_image_1a29ab1f1088b1c8d111dfe02139882ded"></span>float <code class="sig-name descname">cosLookUp</code><span class="sig-paren">(</span>float <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3pcl10RangeImage9cosLookUpEf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Query the cos lookup table. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Protected Static Attributes</p>
<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage17lookup_table_sizeE">
<span id="_CPPv3N3pcl10RangeImage17lookup_table_sizeE"></span><span id="_CPPv2N3pcl10RangeImage17lookup_table_sizeE"></span><span id="pcl::RangeImage::lookup_table_size__iC"></span><span class="target" id="classpcl_1_1_range_image_1a9429abb4524c74600122006d213242ee"></span><em class="property">const</em> int <code class="sig-name descname">lookup_table_size</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage17lookup_table_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage17asin_lookup_tableE">
<span id="_CPPv3N3pcl10RangeImage17asin_lookup_tableE"></span><span id="_CPPv2N3pcl10RangeImage17asin_lookup_tableE"></span><span id="pcl::RangeImage::asin_lookup_table__std::vector:float:"></span><span class="target" id="classpcl_1_1_range_image_1aa864a69c51f0de61769d0bcc6fc3b172"></span>std::vector&lt;float&gt; <code class="sig-name descname">asin_lookup_table</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage17asin_lookup_tableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage17atan_lookup_tableE">
<span id="_CPPv3N3pcl10RangeImage17atan_lookup_tableE"></span><span id="_CPPv2N3pcl10RangeImage17atan_lookup_tableE"></span><span id="pcl::RangeImage::atan_lookup_table__std::vector:float:"></span><span class="target" id="classpcl_1_1_range_image_1a6de3e6d8b323a2d6900cc15815c93d7d"></span>std::vector&lt;float&gt; <code class="sig-name descname">atan_lookup_table</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage17atan_lookup_tableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N3pcl10RangeImage16cos_lookup_tableE">
<span id="_CPPv3N3pcl10RangeImage16cos_lookup_tableE"></span><span id="_CPPv2N3pcl10RangeImage16cos_lookup_tableE"></span><span id="pcl::RangeImage::cos_lookup_table__std::vector:float:"></span><span class="target" id="classpcl_1_1_range_image_1aa811b322d035983d020b3599a06fee3d"></span>std::vector&lt;float&gt; <code class="sig-name descname">cos_lookup_table</code><a class="headerlink" href="#_CPPv4N3pcl10RangeImage16cos_lookup_tableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>